<html>
    <script>
        const XZ_OK = 0;
        const XZ_STREAM_END = 1;

        class XzContext {
            constructor(moduleInstance) {
                this.exports = moduleInstance.exports;
                this.memory = this.exports.memory;
                this.ptr = this.exports.create_context();
                this._refresh();
                this.bufSize = this.mem32[0];
                this.inStart = this.mem32[1] - this.ptr;
                this.inEnd = this.inStart + this.bufSize;
                this.outStart = this.mem32[4] - this.ptr;
            }

            supplyInput(sourceDataUint8Array) {
                const inBuffer = this.mem8.subarray(this.inStart, this.inEnd);
                inBuffer.set(sourceDataUint8Array, 0);
                this.exports.supply_input(this.ptr, sourceDataUint8Array.byteLength);
                this._refresh();
            }

            getNextOutput() {
                const result = this.exports.get_next_output(this.ptr);
                this._refresh();
                if (result !== XZ_OK && result !== XZ_STREAM_END) {
                    throw new Error(`get_next_output failed with error code ${result}`);
                }
                const outChunk = this.mem8.subarray(this.outStart, this.outStart + /* outPos */ this.mem32[5]);
                return { outChunk, finished: result === XZ_STREAM_END };
            }

            needsMoreInput() {
                return /* inPos */ this.mem32[2] === /* inSize */ this.mem32[3];
            }

            outputBufferIsFull() {
                return /* outPos */ this.mem32[5] === this.bufSize;
            }

            resetOutputBuffer() {
                this.outPos = this.mem32[5] = 0;
            }

            dispose() {
                this.exports.destroy_context(this.ptr);
                this.exports = null;
            }

            _refresh() {
                if (this.memory.buffer !== this.mem8?.buffer) {
                    this.mem8 = new Uint8Array(this.memory.buffer, this.ptr);
                    this.mem32 = new Uint32Array(this.memory.buffer, this.ptr);
                }
            }
        }

        (async function load() {
            const wasmResponse = await (await fetch('lib/xzwasm.wasm')).arrayBuffer();
            const module = await WebAssembly.instantiate(wasmResponse, {});
            const sourceBuffer = await (await fetch('hello.txt.xz')).arrayBuffer();

            for (var i = 0; i < 3; i++) {
                const context = new XzContext(module.instance);
                try {
                    const outputBuffer = new ArrayBuffer(10*1024*1024);
                    let outputData = new Uint8Array(outputBuffer, 0, 0);
                    let sourceData = new Uint8Array(sourceBuffer);
                    let finished = false;
                    let outChunk;
                    while (!finished) {
                        if (context.needsMoreInput()) {
                            const nextInputLength = Math.min(context.bufSize, sourceData.byteLength);
                            context.supplyInput(sourceData.subarray(0, nextInputLength));
                            sourceData = sourceData.subarray(nextInputLength);
                        }

                        ({ outChunk, finished } = context.getNextOutput());

                        if (finished || context.outputBufferIsFull()) {
                            outputData = new Uint8Array(outputBuffer, 0, outputData.byteLength + outChunk.byteLength);
                            outputData.set(outChunk, outputData.byteLength - outChunk.byteLength);
                            context.resetOutputBuffer();
                        }
                    }

                    console.log(new TextDecoder().decode(outputData));
                } finally {
                    context.dispose();
                }
            }
        })();
    </script>
</html>
